pr_number,commit_hash,filename,function_name,has_docstring,before_body,after_body,has_associated_test,associated_tests
5393,1af8f95785b85d0937153ee63d504c0b51934d80,cli.py,convert,False,"def convert(self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None) -> t.Any:
    items = self.split_envvar_value(value)
    return [super().convert(item, param, ctx) for item in items]","def convert(self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None) -> t.Any:
    try:
        import ssl
    except ImportError:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param) from None
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
5383,6000e80acf931b05b4911c3fa7f3ba33e2b80e64,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value: t.Any, param: click.Parameter | None, ctx: click.Context | None) -> t.Any:
    try:
        import ssl
    except ImportError:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param) from None
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
5344,1d5abfadd7132c9a78e14e5ba6c07aed47115280,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    try:
        import ssl
    except ImportError:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param) from None
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
5231,5bb30270d2e68d8d9278ac6f5abf67049acba662,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    try:
        import ssl
    except ImportError:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param) from None
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
5215,17e146ad949b3d80438faf95e81b53c543cb50f5,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    try:
        import ssl
    except ImportError:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param) from None
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
5161,bda295d37fa3809c95a93d01dd605d0222109889,helpers.py,get_root_path,True,"def get_root_path(import_name: str) -> str:
    """"""Find the root path of a package, or the path that contains a
    module. If it cannot be found, returns the current working
    directory.

    Not to be confused with the value returned by :func:`find_package`.

    :meta private:
    """"""
    mod = sys.modules.get(import_name)
    if mod is not None and hasattr(mod, '__file__') and (mod.__file__ is not None):
        return os.path.dirname(os.path.abspath(mod.__file__))
    spec = importlib.util.find_spec(import_name)
    loader = spec.loader if spec is not None else None
    if loader is None or import_name == '__main__':
        return os.getcwd()
    if hasattr(loader, 'get_filename'):
        filepath = loader.get_filename(import_name)
    else:
        __import__(import_name)
        mod = sys.modules[import_name]
        filepath = getattr(mod, '__file__', None)
        if filepath is None:
            raise RuntimeError(f""No root path can be found for the provided module {import_name!r}. This can happen because the module came from an import hook that does not provide file name information or because it's a namespace package. In this case the root path needs to be explicitly provided."")
    return os.path.dirname(os.path.abspath(filepath))","def get_root_path(import_name: str) -> str:
    """"""Find the root path of a package, or the path that contains a
    module. If it cannot be found, returns the current working
    directory.

    Not to be confused with the value returned by :func:`find_package`.

    :meta private:
    """"""
    mod = sys.modules.get(import_name)
    if mod is not None and hasattr(mod, '__file__') and (mod.__file__ is not None):
        return os.path.dirname(os.path.abspath(mod.__file__))
    try:
        spec = importlib.util.find_spec(import_name)
        if spec is None:
            raise ValueError
    except (ImportError, ValueError):
        loader = None
    else:
        loader = spec.loader
    if loader is None:
        return os.getcwd()
    if hasattr(loader, 'get_filename'):
        filepath = loader.get_filename(import_name)
    else:
        __import__(import_name)
        mod = sys.modules[import_name]
        filepath = getattr(mod, '__file__', None)
        if filepath is None:
            raise RuntimeError(f""No root path can be found for the provided module {import_name!r}. This can happen because the module came from an import hook that does not provide file name information or because it's a namespace package. In this case the root path needs to be explicitly provided."")
    return os.path.dirname(os.path.abspath(filepath))",False,[]
5108,3fbfbad79fe294918459b70eb409d555b20de2c8,testing.py,session_transaction,True,"@contextmanager
def session_transaction(self, *args: t.Any, **kwargs: t.Any) -> t.Generator[SessionMixin, None, None]:
    """"""When used in combination with a ``with`` statement this opens a
        session transaction.  This can be used to modify the session that
        the test client uses.  Once the ``with`` block is left the session is
        stored back.

        ::

            with client.session_transaction() as session:
                session['value'] = 42

        Internally this is implemented by going through a temporary test
        request context and since session handling could depend on
        request variables this function accepts the same arguments as
        :meth:`~flask.Flask.test_request_context` which are directly
        passed through.
        """"""
    cookie_storage = self._cookies if hasattr(self, '_cookies') else self.cookie_jar
    if cookie_storage is None:
        raise TypeError(""Cookies are disabled. Create a client with 'use_cookies=True'."")
    app = self.application
    ctx = app.test_request_context(*args, **kwargs)
    if hasattr(self, '_add_cookies_to_wsgi'):
        self._add_cookies_to_wsgi(ctx.request.environ)
    else:
        self.cookie_jar.inject_wsgi(ctx.request.environ)
    with ctx:
        sess = app.session_interface.open_session(app, ctx.request)
    if sess is None:
        raise RuntimeError('Session backend did not open a session.')
    yield sess
    resp = app.response_class()
    if app.session_interface.is_null_session(sess):
        return
    with ctx:
        app.session_interface.save_session(app, sess, resp)
    if hasattr(self, '_update_cookies_from_response'):
        self._update_cookies_from_response(ctx.request.host.partition(':')[0], resp.headers.getlist('Set-Cookie'))
    else:
        self.cookie_jar.extract_wsgi(ctx.request.environ, resp.headers)","@contextmanager
def session_transaction(self, *args: t.Any, **kwargs: t.Any) -> t.Generator[SessionMixin, None, None]:
    """"""When used in combination with a ``with`` statement this opens a
        session transaction.  This can be used to modify the session that
        the test client uses.  Once the ``with`` block is left the session is
        stored back.

        ::

            with client.session_transaction() as session:
                session['value'] = 42

        Internally this is implemented by going through a temporary test
        request context and since session handling could depend on
        request variables this function accepts the same arguments as
        :meth:`~flask.Flask.test_request_context` which are directly
        passed through.
        """"""
    cookie_storage = self._cookies if hasattr(self, '_cookies') else self.cookie_jar
    if cookie_storage is None:
        raise TypeError(""Cookies are disabled. Create a client with 'use_cookies=True'."")
    app = self.application
    ctx = app.test_request_context(*args, **kwargs)
    if hasattr(self, '_add_cookies_to_wsgi'):
        self._add_cookies_to_wsgi(ctx.request.environ)
    else:
        self.cookie_jar.inject_wsgi(ctx.request.environ)
    with ctx:
        sess = app.session_interface.open_session(app, ctx.request)
    if sess is None:
        raise RuntimeError('Session backend did not open a session.')
    yield sess
    resp = app.response_class()
    if app.session_interface.is_null_session(sess):
        return
    with ctx:
        app.session_interface.save_session(app, sess, resp)
    if hasattr(self, '_update_cookies_from_response'):
        try:
            self._update_cookies_from_response(ctx.request.host.partition(':')[0], ctx.request.path, resp.headers.getlist('Set-Cookie'))
        except TypeError:
            self._update_cookies_from_response(ctx.request.host.partition(':')[0], resp.headers.getlist('Set-Cookie'))
    else:
        self.cookie_jar.extract_wsgi(ctx.request.environ, resp.headers)",False,[]
5071,44ffe6c6d6c90a414de32db1b03d5978f8770271,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    try:
        import ssl
    except ImportError:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param) from None
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
5063,84c007d34f7f0b8737310fe4d67be12c463e0130,cli.py,routes_command,True,"@click.command('routes', short_help='Show the routes for the app.')
@click.option('--sort', '-s', type=click.Choice(('endpoint', 'methods', 'rule', 'match')), default='endpoint', help='Method to sort routes by. ""match"" is the order that Flask will match routes when dispatching a request.')
@click.option('--all-methods', is_flag=True, help='Show HEAD and OPTIONS methods.')
@with_appcontext
def routes_command(sort: str, all_methods: bool) -> None:
    """"""Show all registered routes with endpoints and methods.""""""
    rules = list(current_app.url_map.iter_rules())
    if not rules:
        click.echo('No routes were registered.')
        return
    ignored_methods = set(() if all_methods else ('HEAD', 'OPTIONS'))
    if sort in ('endpoint', 'rule'):
        rules = sorted(rules, key=attrgetter(sort))
    elif sort == 'methods':
        rules = sorted(rules, key=lambda rule: sorted(rule.methods))
    rule_methods = [', '.join(sorted(rule.methods - ignored_methods)) for rule in rules]
    headers = ('Endpoint', 'Methods', 'Rule')
    widths = (max((len(rule.endpoint) for rule in rules)), max((len(methods) for methods in rule_methods)), max((len(rule.rule) for rule in rules)))
    widths = [max(len(h), w) for (h, w) in zip(headers, widths)]
    row = '{{0:<{0}}}  {{1:<{1}}}  {{2:<{2}}}'.format(*widths)
    click.echo(row.format(*headers).strip())
    click.echo(row.format(*('-' * width for width in widths)))
    for (rule, methods) in zip(rules, rule_methods):
        click.echo(row.format(rule.endpoint, methods, rule.rule).rstrip())","@click.command('routes', short_help='Show the routes for the app.')
@click.option('--sort', '-s', type=click.Choice(('endpoint', 'methods', 'domain', 'rule', 'match')), default='endpoint', help=""Method to sort routes by. 'match' is the order that Flask will match routes when dispatching a request."")
@click.option('--all-methods', is_flag=True, help='Show HEAD and OPTIONS methods.')
@with_appcontext
def routes_command(sort: str, all_methods: bool) -> None:
    """"""Show all registered routes with endpoints and methods.""""""
    rules = list(current_app.url_map.iter_rules())
    if not rules:
        click.echo('No routes were registered.')
        return
    ignored_methods = set() if all_methods else {'HEAD', 'OPTIONS'}
    host_matching = current_app.url_map.host_matching
    has_domain = any((rule.host if host_matching else rule.subdomain for rule in rules))
    rows = []
    for rule in rules:
        row = [rule.endpoint, ', '.join(sorted((rule.methods or set()) - ignored_methods))]
        if has_domain:
            row.append((rule.host if host_matching else rule.subdomain) or '')
        row.append(rule.rule)
        rows.append(row)
    headers = ['Endpoint', 'Methods']
    sorts = ['endpoint', 'methods']
    if has_domain:
        headers.append('Host' if host_matching else 'Subdomain')
        sorts.append('domain')
    headers.append('Rule')
    sorts.append('rule')
    try:
        rows.sort(key=itemgetter(sorts.index(sort)))
    except ValueError:
        pass
    rows.insert(0, headers)
    widths = [max((len(row[i]) for row in rows)) for i in range(len(headers))]
    rows.insert(1, ['-' * w for w in widths])
    template = '  '.join((f'{{{i}:<{w}}}' for (i, w) in enumerate(widths)))
    for row in rows:
        click.echo(template.format(*row))",True,['test_cli.py']
5063,84c007d34f7f0b8737310fe4d67be12c463e0130,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    try:
        import ssl
    except ImportError:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param) from None
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
4779,4bc0e4943dfa637361aec2bb18dc9e1fabeaad12,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    try:
        import ssl
    except ImportError:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param) from None
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
4779,bd26928fdb2476fca62f0e621e8f2870250ac2bc,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    try:
        import ssl
    except ImportError:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param) from None
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
4754,de16718b39e3544688130339a0813997e3790c48,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    try:
        import ssl
    except ImportError:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param) from None
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
4749,e3df23374cdb9342a823556170c53c9d987d0d33,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    try:
        import ssl
    except ImportError:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param) from None
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
4720,ef95998d79eed3b8350d8db825e3d98f25c179f2,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    try:
        import ssl
    except ImportError:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param) from None
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
4719,7d53a129cf1b28f1a88491ae50877473b68bdb54,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    try:
        import ssl
    except ImportError:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param) from None
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
4718,5d8e35653fca0d7ee01519d556c7851089de82ea,cli.py,run_command,True,"@click.command('run', short_help='Run a development server.')
@click.option('--host', '-h', default='127.0.0.1', help='The interface to bind to.')
@click.option('--port', '-p', default=5000, help='The port to bind to.')
@click.option('--cert', type=CertParamType(), help='Specify a certificate file to use HTTPS.', is_eager=True)
@click.option('--key', type=click.Path(exists=True, dir_okay=False, resolve_path=True), callback=_validate_key, expose_value=False, help='The key file to use when specifying a certificate.')
@click.option('--reload/--no-reload', default=None, help='Enable or disable the reloader. By default the reloader is active if debug is enabled.')
@click.option('--debugger/--no-debugger', default=None, help='Enable or disable the debugger. By default the debugger is active if debug is enabled.')
@click.option('--eager-loading/--lazy-loading', default=None, help='Enable or disable eager loading. By default eager loading is enabled if the reloader is disabled.')
@click.option('--with-threads/--without-threads', default=True, help='Enable or disable multithreading.')
@click.option('--extra-files', default=None, type=SeparatedPathType(), help=f'Extra files that trigger a reload on change. Multiple paths are separated by {os.path.pathsep!r}.')
@click.option('--exclude-patterns', default=None, type=SeparatedPathType(), help=f'Files matching these fnmatch patterns will not trigger a reload on change. Multiple patterns are separated by {os.path.pathsep!r}.')
@pass_script_info
def run_command(info, host, port, reload, debugger, eager_loading, with_threads, cert, extra_files, exclude_patterns):
    """"""Run a local development server.

    This server is for development purposes only. It does not provide
    the stability, security, or performance of production WSGI servers.

    The reloader and debugger are enabled by default with the
    '--env development' or '--debug' options.
    """"""
    app = DispatchingApp(info.load_app, use_eager_loading=eager_loading)
    debug = get_debug_flag()
    if reload is None:
        reload = debug
    if debugger is None:
        debugger = debug
    show_server_banner(get_env(), debug, info.app_import_path, eager_loading)
    from werkzeug.serving import run_simple
    run_simple(host, port, app, use_reloader=reload, use_debugger=debugger, threaded=with_threads, ssl_context=cert, extra_files=extra_files, exclude_patterns=exclude_patterns)","@click.command('run', short_help='Run a development server.')
@click.option('--host', '-h', default='127.0.0.1', help='The interface to bind to.')
@click.option('--port', '-p', default=5000, help='The port to bind to.')
@click.option('--cert', type=CertParamType(), help='Specify a certificate file to use HTTPS.', is_eager=True)
@click.option('--key', type=click.Path(exists=True, dir_okay=False, resolve_path=True), callback=_validate_key, expose_value=False, help='The key file to use when specifying a certificate.')
@click.option('--reload/--no-reload', default=None, help='Enable or disable the reloader. By default the reloader is active if debug is enabled.')
@click.option('--debugger/--no-debugger', default=None, help='Enable or disable the debugger. By default the debugger is active if debug is enabled.')
@click.option('--with-threads/--without-threads', default=True, help='Enable or disable multithreading.')
@click.option('--extra-files', default=None, type=SeparatedPathType(), help=f'Extra files that trigger a reload on change. Multiple paths are separated by {os.path.pathsep!r}.')
@click.option('--exclude-patterns', default=None, type=SeparatedPathType(), help=f'Files matching these fnmatch patterns will not trigger a reload on change. Multiple patterns are separated by {os.path.pathsep!r}.')
@pass_script_info
def run_command(info, host, port, reload, debugger, with_threads, cert, extra_files, exclude_patterns):
    """"""Run a local development server.

    This server is for development purposes only. It does not provide
    the stability, security, or performance of production WSGI servers.

    The reloader and debugger are enabled by default with the
    '--env development' or '--debug' options.
    """"""
    try:
        app = info.load_app()
    except Exception as e:
        if is_running_from_reloader():
            traceback.print_exc()
            err = e

            def app(environ, start_response):
                raise err from None
        else:
            raise e from None
    debug = get_debug_flag()
    if reload is None:
        reload = debug
    if debugger is None:
        debugger = debug
    show_server_banner(get_env(), debug, info.app_import_path)
    from werkzeug.serving import run_simple
    run_simple(host, port, app, use_reloader=reload, use_debugger=debugger, threaded=with_threads, ssl_context=cert, extra_files=extra_files, exclude_patterns=exclude_patterns)",True,['test_cli.py']
4718,5d8e35653fca0d7ee01519d556c7851089de82ea,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    try:
        import ssl
    except ImportError:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param) from None
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
4682,82c2e0366ce6b74a3786a64631ce58b85b3a7d4e,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    try:
        import ssl
    except ImportError:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param) from None
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
4662,5544d09477af3221d988ec18b086930c2d9e67cd,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    try:
        import ssl
    except ImportError:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param) from None
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
4647,c9e000b9cea2e117218d460874d86301fbb43c43,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    try:
        import ssl
    except ImportError:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param) from None
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
4646,99fa3c36abc03cd5b3407df34dce74e879ea377a,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    try:
        import ssl
    except ImportError:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param) from None
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
4642,4f03a769d44f6740490dd4ddf70e094c12a6090c,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    try:
        import ssl
    except ImportError:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param) from None
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
4642,aa801c431ad1f979bce3ea1afbd88e7796ebfd7e,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    try:
        import ssl
    except ImportError:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param) from None
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
4606,1232d698600e11dcb83bb5dc349ca785eae02d2f,cli.py,load_dotenv,True,"def load_dotenv(path=None):
    """"""Load ""dotenv"" files in order of precedence to set environment variables.

    If an env var is already set it is not overwritten, so earlier files in the
    list are preferred over later files.

    This is a no-op if `python-dotenv`_ is not installed.

    .. _python-dotenv: https://github.com/theskumar/python-dotenv#readme

    :param path: Load the file at this location instead of searching.
    :return: ``True`` if a file was loaded.

    .. versionchanged:: 1.1.0
        Returns ``False`` when python-dotenv is not installed, or when
        the given path isn't a file.

    .. versionchanged:: 2.0
        When loading the env files, set the default encoding to UTF-8.

    .. versionadded:: 1.0
    """"""
    if dotenv is None:
        if path or os.path.isfile('.env') or os.path.isfile('.flaskenv'):
            click.secho(' * Tip: There are .env or .flaskenv files present. Do ""pip install python-dotenv"" to use them.', fg='yellow', err=True)
        return False
    if path is not None:
        if os.path.isfile(path):
            return dotenv.load_dotenv(path, encoding='utf-8')
        return False
    new_dir = None
    for name in ('.env', '.flaskenv'):
        path = dotenv.find_dotenv(name, usecwd=True)
        if not path:
            continue
        if new_dir is None:
            new_dir = os.path.dirname(path)
        dotenv.load_dotenv(path, encoding='utf-8')
    return new_dir is not None","def load_dotenv(path=None):
    """"""Load ""dotenv"" files in order of precedence to set environment variables.

    If an env var is already set it is not overwritten, so earlier files in the
    list are preferred over later files.

    This is a no-op if `python-dotenv`_ is not installed.

    .. _python-dotenv: https://github.com/theskumar/python-dotenv#readme

    :param path: Load the file at this location instead of searching.
    :return: ``True`` if a file was loaded.

    .. versionchanged:: 1.1.0
        Returns ``False`` when python-dotenv is not installed, or when
        the given path isn't a file.

    .. versionchanged:: 2.0
        When loading the env files, set the default encoding to UTF-8.

    .. versionadded:: 1.0
    """"""
    try:
        import dotenv
    except ImportError:
        if path or os.path.isfile('.env') or os.path.isfile('.flaskenv'):
            click.secho(' * Tip: There are .env or .flaskenv files present. Do ""pip install python-dotenv"" to use them.', fg='yellow', err=True)
        return False
    if path is not None:
        if os.path.isfile(path):
            return dotenv.load_dotenv(path, encoding='utf-8')
        return False
    new_dir = None
    for name in ('.env', '.flaskenv'):
        path = dotenv.find_dotenv(name, usecwd=True)
        if not path:
            continue
        if new_dir is None:
            new_dir = os.path.dirname(path)
        dotenv.load_dotenv(path, encoding='utf-8')
    return new_dir is not None",True,['test_cli.py']
4606,1232d698600e11dcb83bb5dc349ca785eae02d2f,cli.py,_validate_key,True,"def _validate_key(ctx, param, value):
    """"""The ``--key`` option must be specified when ``--cert`` is a file.
    Modifies the ``cert`` param to be a ``(cert, key)`` pair if needed.
    """"""
    cert = ctx.params.get('cert')
    is_adhoc = cert == 'adhoc'
    is_context = ssl and isinstance(cert, ssl.SSLContext)
    if value is not None:
        if is_adhoc:
            raise click.BadParameter('When ""--cert"" is ""adhoc"", ""--key"" is not used.', ctx, param)
        if is_context:
            raise click.BadParameter('When ""--cert"" is an SSLContext object, ""--key is not used.', ctx, param)
        if not cert:
            raise click.BadParameter('""--cert"" must also be specified.', ctx, param)
        ctx.params['cert'] = (cert, value)
    elif cert and (not (is_adhoc or is_context)):
        raise click.BadParameter('Required when using ""--cert"".', ctx, param)
    return value","def _validate_key(ctx, param, value):
    """"""The ``--key`` option must be specified when ``--cert`` is a file.
    Modifies the ``cert`` param to be a ``(cert, key)`` pair if needed.
    """"""
    cert = ctx.params.get('cert')
    is_adhoc = cert == 'adhoc'
    try:
        import ssl
    except ImportError:
        is_context = False
    else:
        is_context = isinstance(cert, ssl.SSLContext)
    if value is not None:
        if is_adhoc:
            raise click.BadParameter('When ""--cert"" is ""adhoc"", ""--key"" is not used.', ctx, param)
        if is_context:
            raise click.BadParameter('When ""--cert"" is an SSLContext object, ""--key is not used.', ctx, param)
        if not cert:
            raise click.BadParameter('""--cert"" must also be specified.', ctx, param)
        ctx.params['cert'] = (cert, value)
    elif cert and (not (is_adhoc or is_context)):
        raise click.BadParameter('Required when using ""--cert"".', ctx, param)
    return value",True,['test_cli.py']
4606,1232d698600e11dcb83bb5dc349ca785eae02d2f,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    try:
        import ssl
    except ImportError:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param) from None
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
4572,8ddbad9ccdc176b9d57a4aff0076c1c58c455318,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
4560,1e5dd430223369d13ea94ffffe22bca53a98e730,scaffold.py,_get_exc_class_and_code,True,"@staticmethod
def _get_exc_class_and_code(exc_class_or_code: t.Union[t.Type[Exception], int]) -> t.Tuple[t.Type[Exception], t.Optional[int]]:
    """"""Get the exception class being handled. For HTTP status codes
        or ``HTTPException`` subclasses, return both the exception and
        status code.

        :param exc_class_or_code: Any exception class, or an HTTP status
            code as an integer.
        """"""
    exc_class: t.Type[Exception]
    if isinstance(exc_class_or_code, int):
        exc_class = default_exceptions[exc_class_or_code]
    else:
        exc_class = exc_class_or_code
    assert issubclass(exc_class, Exception), 'Custom exceptions must be subclasses of Exception.'
    if issubclass(exc_class, HTTPException):
        return (exc_class, exc_class.code)
    else:
        return (exc_class, None)","@staticmethod
def _get_exc_class_and_code(exc_class_or_code: t.Union[t.Type[Exception], int]) -> t.Tuple[t.Type[Exception], t.Optional[int]]:
    """"""Get the exception class being handled. For HTTP status codes
        or ``HTTPException`` subclasses, return both the exception and
        status code.

        :param exc_class_or_code: Any exception class, or an HTTP status
            code as an integer.
        """"""
    exc_class: t.Type[Exception]
    if isinstance(exc_class_or_code, int):
        try:
            exc_class = default_exceptions[exc_class_or_code]
        except KeyError:
            raise ValueError(f""'{exc_class_or_code}' is not a recognized HTTP error code. Use a subclass of HTTPException with that code instead."") from None
    else:
        exc_class = exc_class_or_code
    if isinstance(exc_class, Exception):
        raise TypeError(f'{exc_class!r} is an instance, not a class. Handlers can only be registered for Exception classes or HTTP error codes.')
    if not issubclass(exc_class, Exception):
        raise ValueError(f""'{exc_class.__name__}' is not a subclass of Exception. Handlers can only be registered for Exception classes or HTTP error codes."")
    if issubclass(exc_class, HTTPException):
        return (exc_class, exc_class.code)
    else:
        return (exc_class, None)",False,[]
4544,5050a18a0057df4cda6f6b00483d12d29cb59239,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
4492,6578b493c8c8d5d9b4135cb964dbbc43318cfb12,wrappers.py,on_json_loading_failed,False,"def on_json_loading_failed(self, e: Exception) -> 'te.NoReturn':
    if current_app and current_app.debug:
        raise BadRequest(f'Failed to decode JSON object: {e}')
    raise BadRequest()","def on_json_loading_failed(self, e: ValueError) -> t.Any:
    try:
        return super().on_json_loading_failed(e)
    except BadRequest as e:
        if current_app and current_app.debug:
            raise
        raise BadRequest() from e",False,[]
4479,4eb5e9455b2a8f15f3dc5065a47f8e43ac47e539,config.py,from_prefixed_env,True,"def from_prefixed_env(self, prefix: str='FLASK_', *, loads: t.Callable[[t.Union[str, bytes]], t.Any]=_json_loads) -> bool:
    """"""Updates the config from environment variables with the prefix.

        Calling this method will result in every environment variable
        starting with **prefix** being placed into the configuration
        without the **prefix**. The prefix is configurable as an
        argument. Note that this method updates the existing config.

        For example if there is an environment variable
        ``FLASK_SECRET_KEY`` with value ``secretly`` and the prefix is
        ``FLASK_`` the config will contain the key ``SECRET_KEY`` with
        the value ``secretly`` after calling this method.

        The value of the environment variable will be passed to the
        **loads** parameter before being placed into the config. By
        default **loads** utilises the stdlib json.loads to parse the
        value, falling back to the value itself on parsing error.

        :param loads: A callable that takes a str (or bytes) returns
            the parsed value.
        :return: Always returns ``True``.

        .. versionadded:: 2.1.0

        """"""
    mapping = {}
    for (raw_key, value) in os.environ.items():
        if raw_key.startswith(prefix):
            key = raw_key[len(prefix):]
            mapping[key] = loads(value)
    return self.from_mapping(mapping)","def from_prefixed_env(self, prefix: str='FLASK', *, loads: t.Callable[[str], t.Any]=json.loads) -> bool:
    """"""Load any environment variables that start with ``FLASK_``,
        dropping the prefix from the env key for the config key. Values
        are passed through a loading function to attempt to convert them
        to more specific types than strings.

        Keys are loaded in :func:`sorted` order.

        The default loading function attempts to parse values as any
        valid JSON type, including dicts and lists.

        Specific items in nested dicts can be set by separating the
        keys with double underscores (``__``). If an intermediate key
        doesn't exist, it will be initialized to an empty dict.

        :param prefix: Load env vars that start with this prefix,
            separated with an underscore (``_``).
        :param loads: Pass each string value to this function and use
            the returned value as the config value. If any error is
            raised it is ignored and the value remains a string. The
            default is :func:`json.loads`.

        .. versionadded:: 2.1
        """"""
    prefix = f'{prefix}_'
    len_prefix = len(prefix)
    for key in sorted(os.environ):
        if not key.startswith(prefix):
            continue
        value = os.environ[key]
        try:
            value = loads(value)
        except Exception:
            pass
        key = key[len_prefix:]
        if '__' not in key:
            self[key] = value
            continue
        current = self
        (*parts, tail) = key.split('__')
        for part in parts:
            if part not in current:
                current[part] = {}
            current = current[part]
        current[tail] = value
    return True",True,['test_config.py']
4461,aa13521d42bfdb66bb0d89005cbe54a84eaa4fda,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
4420,751d85f3de3f726446bb12e4ddfae885a6645ba1,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
4337,e21e003f62b57c35e1832c0bf14e9cd27f4e5bea,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
4310,e679a85b80df354f8632f8ab3e40135f16f5e6d0,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
4283,6a4bf9eec13e035cf10ecc16e462049b4c967e41,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
4189,beae1249f7e580779ae18d2d831f7ec51e5aff98,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param) from None
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
4174,9f0da9b770abfe3376ca0bbb09c535b42071feeb,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
4169,aa6dd09c2cab5eb15a45d73b5ade24b7b4131c5a,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
4139,51196575479e34c3ea43612e1eb770db3aa5d114,auth.py,register,True,"@bp.route('/register', methods=('GET', 'POST'))
def register():
    """"""Register a new user.

    Validates that the username is not already taken. Hashes the
    password for security.
    """"""
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        db = get_db()
        error = None
        if not username:
            error = 'Username is required.'
        elif not password:
            error = 'Password is required.'
        elif db.execute('SELECT id FROM user WHERE username = ?', (username,)).fetchone() is not None:
            error = f'User {username} is already registered.'
        if error is None:
            db.execute('INSERT INTO user (username, password) VALUES (?, ?)', (username, generate_password_hash(password)))
            db.commit()
            return redirect(url_for('auth.login'))
        flash(error)
    return render_template('auth/register.html')","@bp.route('/register', methods=('GET', 'POST'))
def register():
    """"""Register a new user.

    Validates that the username is not already taken. Hashes the
    password for security.
    """"""
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        db = get_db()
        error = None
        if not username:
            error = 'Username is required.'
        elif not password:
            error = 'Password is required.'
        if error is None:
            try:
                db.execute('INSERT INTO user (username, password) VALUES (?, ?)', (username, generate_password_hash(password)))
                db.commit()
            except db.IntegrityError:
                error = f'User {username} is already registered.'
            else:
                return redirect(url_for('auth.login'))
        flash(error)
    return render_template('auth/register.html')",False,[]
3973,77237093da25438c88b0a74c374a397d4bf823eb,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
3972,26a6cc0f94dd25390e2b2d7462bb4a414a862b16,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
3960,32272da9ac6e16fa22d3401b2d995d5bf3db9492,cli.py,shell_command,True,"@click.command('shell', short_help='Run a shell in the app context.')
@with_appcontext
def shell_command():
    """"""Run an interactive Python shell in the context of a given
    Flask application.  The application will populate the default
    namespace of this shell according to its configuration.

    This is useful for executing small snippets of management code
    without having to manually configure the application.
    """"""
    import code
    from .globals import _app_ctx_stack
    app = _app_ctx_stack.top.app
    banner = f'Python {sys.version} on {sys.platform}\nApp: {app.import_name} [{app.env}]\nInstance: {app.instance_path}'
    ctx = {}
    startup = os.environ.get('PYTHONSTARTUP')
    if startup and os.path.isfile(startup):
        with open(startup) as f:
            eval(compile(f.read(), startup, 'exec'), ctx)
    ctx.update(app.make_shell_context())
    code.interact(banner=banner, local=ctx)","@click.command('shell', short_help='Run a shell in the app context.')
@with_appcontext
def shell_command():
    """"""Run an interactive Python shell in the context of a given
    Flask application.  The application will populate the default
    namespace of this shell according to its configuration.

    This is useful for executing small snippets of management code
    without having to manually configure the application.
    """"""
    import code
    from .globals import _app_ctx_stack
    app = _app_ctx_stack.top.app
    banner = f'Python {sys.version} on {sys.platform}\nApp: {app.import_name} [{app.env}]\nInstance: {app.instance_path}'
    ctx = {}
    startup = os.environ.get('PYTHONSTARTUP')
    if startup and os.path.isfile(startup):
        with open(startup) as f:
            eval(compile(f.read(), startup, 'exec'), ctx)
    ctx.update(app.make_shell_context())
    interactive_hook = getattr(sys, '__interactivehook__', None)
    if interactive_hook is not None:
        try:
            import readline
            from rlcompleter import Completer
        except ImportError:
            pass
        else:
            readline.set_completer(Completer(ctx).complete)
        interactive_hook()
    code.interact(banner=banner, local=ctx)",False,[]
3960,32272da9ac6e16fa22d3401b2d995d5bf3db9492,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
3933,ef52e3e4a379b16a8b906ff101c6edae71d80dc9,scaffold.py,register_error_handler,True,"@setupmethod
def register_error_handler(self, code_or_exception, f):
    """"""Alternative error attach function to the :meth:`errorhandler`
        decorator that is more straightforward to use for non decorator
        usage.

        .. versionadded:: 0.7
        """"""
    self._register_error_handler(None, code_or_exception, f)","@setupmethod
def register_error_handler(self, code_or_exception, f):
    """"""Alternative error attach function to the :meth:`errorhandler`
        decorator that is more straightforward to use for non decorator
        usage.

        .. versionadded:: 0.7
        """"""
    if isinstance(code_or_exception, HTTPException):
        raise ValueError(f'Tried to register a handler for an exception instance {code_or_exception!r}. Handlers can only be registered for exception classes or HTTP error codes.')
    try:
        (exc_class, code) = self._get_exc_class_and_code(code_or_exception)
    except KeyError:
        raise KeyError(f""'{code_or_exception}' is not a recognized HTTP error code. Use a subclass of HTTPException with that code instead."")
    self.error_handler_spec[None][code][exc_class] = f",False,[]
3932,33145c36991c503aeb1e5870c27b720ec80d5079,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
3894,055cdc2625c0cdf8cea87524f5c6bcf07f7e5005,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
3728,cf3089a8f82d50430da4cbe690c1ef11d30241ec,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
3711,253570784cdcc85d82142128ce33e3b9d8f8db14,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
3564,ff2f71379b719903e462ed6a83801b1736009000,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
3563,fcac7f11cf5fbdaa43c3a8c305b31cf0a43a70d3,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
3562,8b5f760b7285c863d5c7a4ee10adb5eb7ac60a05,__init__.py,dump,True,"def dump(obj, fp, app=None, **kwargs):
    """"""Like :func:`dumps` but writes into a file object.""""""
    _dump_arg_defaults(kwargs, app=app)
    encoding = kwargs.pop('encoding', None)
    if encoding is not None:
        fp = _wrap_writer_for_text(fp, encoding)
    _json.dump(obj, fp, **kwargs)","def dump(obj, fp, app=None, **kwargs):
    """"""Like :func:`dumps` but writes into a file object.""""""
    _dump_arg_defaults(kwargs, app=app)
    encoding = kwargs.pop('encoding', None)
    show_warning = encoding is not None
    try:
        fp.write('')
    except TypeError:
        show_warning = True
        fp = io.TextIOWrapper(fp, encoding or 'utf-8')
    if show_warning:
        warnings.warn(""Writing to a binary file, and the 'encoding' argument, is deprecated and will be removed in 2.1."", DeprecationWarning, stacklevel=2)
    _json.dump(obj, fp, **kwargs)",False,[]
3560,84cbfc0698f429c93450cd6f1600e56b41a30247,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
3554,662c245795c7cbb5dbd657a2d707c62c16770c18,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super(SeparatedPathType, self).convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if sys.version_info < (2, 7, 9):
            if obj:
                return obj
        elif isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
3554,57d628ca74513480908a63a6b66c1c8b1af896e8,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super(SeparatedPathType, self).convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
3554,524fd0bc8cec7bfe8167c9c98cb5511b01a0f4c6,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super(SeparatedPathType, self).convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
3554,2ae740dd4903bbe5f3864384bcdf2ab2d4638bce,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super().convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
3492,bcde664f9a3f6ef3b3d33c6c4e7c3cb3acc2af30,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super(SeparatedPathType, self).convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import cryptography
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires the cryptography library.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if sys.version_info < (2, 7, 9):
            if obj:
                return obj
        elif isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
3434,240a11052bb2ef1ba0bbcc5d503601a175926f75,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super(SeparatedPathType, self).convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import OpenSSL
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires pyOpenSSL.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if sys.version_info < (2, 7, 9):
            if obj:
                return obj
        elif isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
3434,a671e47921f6b3f1e6c24f34f23b83ed13fe63b6,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super(SeparatedPathType, self).convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import OpenSSL
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires pyOpenSSL.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if sys.version_info < (2, 7, 9):
            if obj:
                return obj
        elif isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
3299,c478e5d52f4985a9a58f1ac1d229b47e9f6fe24f,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super(SeparatedPathType, self).convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import OpenSSL
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires pyOpenSSL.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if sys.version_info < (2, 7, 9):
            if obj:
                return obj
        elif isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
3247,53c893b646252d610e877eb9385e9e250a1ae5e1,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super(SeparatedPathType, self).convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import OpenSSL
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires pyOpenSSL.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if sys.version_info < (2, 7, 9):
            if obj:
                return obj
        elif isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
3246,43483683b2bc8da85f00ccccdfb8d9d5c77a6bb3,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super(SeparatedPathType, self).convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import OpenSSL
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires pyOpenSSL.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if sys.version_info < (2, 7, 9):
            if obj:
                return obj
        elif isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
3242,1718f1934c4fa709b42230b3ee5d6f803ec65df4,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super(SeparatedPathType, self).convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import OpenSSL
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires pyOpenSSL.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if sys.version_info < (2, 7, 9):
            if obj:
                return obj
        elif isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
3241,b46f5942a528053034fecf210572ee04bc4a3284,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super(SeparatedPathType, self).convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    if ssl is None:
        raise click.BadParameter('Using ""--cert"" requires Python to be compiled with SSL support.', ctx, param)
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import OpenSSL
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires pyOpenSSL.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if sys.version_info < (2, 7, 9):
            if obj:
                return obj
        elif isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
3234,2a97d4a706c329b15b9119101254de15c80410cc,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super(SeparatedPathType, self).convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import OpenSSL
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires pyOpenSSL.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if sys.version_info < (2, 7, 9):
            if obj:
                return obj
        elif isinstance(obj, ssl.SSLContext):
            return obj
        raise",False,[]
3229,a5ff3cd01b8a78b5ed2961a8095290fed4e2a0d5,cli.py,convert,False,"def convert(self, value, param, ctx):
    items = self.split_envvar_value(value)
    super_convert = super(SeparatedPathType, self).convert
    return [super_convert(item, param, ctx) for item in items]","def convert(self, value, param, ctx):
    try:
        return self.path_type(value, param, ctx)
    except click.BadParameter:
        value = click.STRING(value, param, ctx).lower()
        if value == 'adhoc':
            try:
                import OpenSSL
            except ImportError:
                raise click.BadParameter('Using ad-hoc certificates requires pyOpenSSL.', ctx, param)
            return value
        obj = import_string(value, silent=True)
        if sys.version_info < (2, 7, 9):
            if obj:
                return obj
        elif isinstance(obj, ssl.SSLContext):
            return obj
        raise",True,['test_cli.py']
2624,9bf5c3b3a3bdc3f2f2dcca2b5747378470d0d354,make-release.py,main,False,"def main():
    os.chdir(os.path.join(os.path.dirname(__file__), '..'))
    rv = parse_changelog()
    if rv is None:
        fail('Could not parse changelog')
    (version, release_date, codename) = rv
    dev_version = bump_version(version) + '-dev'
    info('Releasing %s (codename %s, release date %s)', version, codename, release_date.strftime('%d/%m/%Y'))
    tags = get_git_tags()
    if version in tags:
        fail('Version ""%s"" is already tagged', version)
    if release_date.date() != date.today():
        fail('Release date is not today (%s != %s)', release_date.date(), date.today())
    if not git_is_clean():
        fail('You have uncommitted changes in git')
    set_init_version(version)
    make_git_commit('Bump version number to %s', version)
    make_git_tag(version)
    build_and_upload()
    set_init_version(dev_version)","def main():
    os.chdir(os.path.join(os.path.dirname(__file__), '..'))
    rv = parse_changelog()
    if rv is None:
        fail('Could not parse changelog')
    (version, release_date, codename) = rv
    dev_version = bump_version(version) + '.dev'
    info('Releasing %s (codename %s, release date %s)', version, codename, release_date.strftime('%d/%m/%Y'))
    tags = get_git_tags()
    if version in tags:
        fail('Version ""%s"" is already tagged', version)
    if release_date.date() != date.today():
        fail('Release date is not today (%s != %s)', release_date.date(), date.today())
    if not git_is_clean():
        fail('You have uncommitted changes in git')
    try:
        import wheel
    except ImportError:
        fail('You need to install the wheel package.')
    set_init_version(version)
    make_git_commit('Bump version number to %s', version)
    make_git_tag(version)
    build()
    set_init_version(dev_version)",False,[]
2530,2cba0d77eef983b605bf2f5c85a9d02fe212eda0,cli.py,_called_with_wrong_args,True,"def _called_with_wrong_args(factory, exc_info):
    (exc_type, exc_value, tb) = exc_info
    return exc_type is TypeError and str(exc_value).startswith(('%s() takes' % factory.__name__, '%s() missing' % factory.__name__))","def _called_with_wrong_args(factory):
    """"""Check whether calling a function raised a ``TypeError`` because
    the call failed or because something in the factory raised the
    error.

    :param factory: the factory function that was called
    :return: true if the call failed
    """"""
    tb = sys.exc_info()[2]
    try:
        while tb is not None:
            if tb.tb_frame.f_code is factory.__code__:
                return False
            tb = tb.tb_next
        return True
    finally:
        del tb",False,[]
2350,859d9a9d5c3da114132ec9f0e515e1fa8030f68f,app.py,_register_error_handler,True,"@setupmethod
def _register_error_handler(self, key, code_or_exception, f):
    """"""
        :type key: None|str
        :type code_or_exception: int|T<=Exception
        :type f: callable
        """"""
    if isinstance(code_or_exception, HTTPException):
        raise ValueError('Tried to register a handler for an exception instance {0!r}. Handlers can only be registered for exception classes or HTTP error codes.'.format(code_or_exception))
    (exc_class, code) = self._get_exc_class_and_code(code_or_exception)
    handlers = self.error_handler_spec.setdefault(key, {}).setdefault(code, {})
    handlers[exc_class] = f","@setupmethod
def _register_error_handler(self, key, code_or_exception, f):
    """"""
        :type key: None|str
        :type code_or_exception: int|T<=Exception
        :type f: callable
        """"""
    if isinstance(code_or_exception, HTTPException):
        raise ValueError('Tried to register a handler for an exception instance {0!r}. Handlers can only be registered for exception classes or HTTP error codes.'.format(code_or_exception))
    try:
        (exc_class, code) = self._get_exc_class_and_code(code_or_exception)
    except KeyError:
        raise KeyError(""'{0}' is not a recognized HTTP error code. Use a subclass of HTTPException with that code instead."".format(code_or_exception))
    handlers = self.error_handler_spec.setdefault(key, {}).setdefault(code, {})
    handlers[exc_class] = f",False,[]
2314,668061a5fc928a5055815acf818b02baf1aef37b,app.py,_find_error_handler,True,"def _find_error_handler(self, e):
    """"""Finds a registered error handler for the request’s blueprint.
        Otherwise falls back to the app, returns None if not a suitable
        handler is found.
        """"""
    (exc_class, code) = self._get_exc_class_and_code(type(e))

    def find_handler(handler_map):
        if not handler_map:
            return
        for cls in exc_class.__mro__:
            handler = handler_map.get(cls)
            if handler is not None:
                handler_map[exc_class] = handler
                return handler
    handler = find_handler(self.error_handler_spec.get(request.blueprint, {}).get(code))
    if handler is not None:
        return handler
    return find_handler(self.error_handler_spec[None].get(code))","def _find_error_handler(self, e):
    """"""Finds a registered error handler for the request’s blueprint.
        Otherwise falls back to the app, returns None if not a suitable
        handler is found.
        """"""
    (exc_class, code) = self._get_exc_class_and_code(type(e))

    def find_handler(handler_map):
        if not handler_map:
            return
        for cls in exc_class.__mro__:
            handler = handler_map.get(cls)
            if handler is not None:
                handler_map[exc_class] = handler
                return handler
    handler = find_handler(self.error_handler_spec.get(request.blueprint, {}).get(code))
    if handler is not None:
        return handler
    handler = find_handler(self.error_handler_spec[None].get(code))
    if handler is not None:
        return handler
    try:
        handler = find_handler(self.error_handler_spec[None][None])
    except KeyError:
        handler = None
    return handler",False,[]
2297,ced719ea18a56f6c4075e08dbe05f0e77eac1866,cli.py,find_best_app,True,"def find_best_app(module):
    """"""Given a module instance this tries to find the best possible
    application in the module or raises an exception.
    """"""
    from . import Flask
    for attr_name in ('app', 'application'):
        app = getattr(module, attr_name, None)
        if app is not None and isinstance(app, Flask):
            return app
    matches = [v for (k, v) in iteritems(module.__dict__) if isinstance(v, Flask)]
    if len(matches) == 1:
        return matches[0]
    raise NoAppException('Failed to find application in module ""%s"".  Are you sure it contains a Flask application?  Maybe you wrapped it in a WSGI middleware or you are using a factory function.' % module.__name__)","def find_best_app(module):
    """"""Given a module instance this tries to find the best possible
    application in the module or raises an exception.
    """"""
    from . import Flask
    for attr_name in ('app', 'application'):
        app = getattr(module, attr_name, None)
        if app is not None and isinstance(app, Flask):
            return app
    matches = [v for (k, v) in iteritems(module.__dict__) if isinstance(v, Flask)]
    if len(matches) == 1:
        return matches[0]
    for attr_name in ('create_app', 'make_app'):
        app_factory = getattr(module, attr_name, None)
        if app_factory is not None and callable(app_factory):
            try:
                app = app_factory()
                if app is not None and isinstance(app, Flask):
                    return app
            except TypeError:
                raise NoAppException('Auto-detected ""%s()"" in module ""%s"", but could not call it without specifying arguments.' % (attr_name, module.__name__))
    raise NoAppException('Failed to find application in module ""%s"".  Are you sure it contains a Flask application?  Maybe you wrapped it in a WSGI middleware or you are using a factory function.' % module.__name__)",True,['test_cli.py']
2256,697f7b9365304c45216e6c8dd307d931ea1506d0,app.py,make_response,True,"def make_response(self, rv):
    """"""Converts the return value from a view function to a real
        response object that is an instance of :attr:`response_class`.

        The following types are allowed for `rv`:

        .. tabularcolumns:: |p{3.5cm}|p{9.5cm}|

        ======================= ===========================================
        :attr:`response_class`  the object is returned unchanged
        :class:`str`            a response object is created with the
                                string as body
        :class:`unicode`        a response object is created with the
                                string encoded to utf-8 as body
        a WSGI function         the function is called as WSGI application
                                and buffered as response object
        :class:`tuple`          A tuple in the form ``(response, status,
                                headers)`` or ``(response, headers)``
                                where `response` is any of the
                                types defined here, `status` is a string
                                or an integer and `headers` is a list or
                                a dictionary with header values.
        ======================= ===========================================

        :param rv: the return value from the view function

        .. versionchanged:: 0.9
           Previously a tuple was interpreted as the arguments for the
           response object.
        """"""
    status_or_headers = headers = None
    if isinstance(rv, tuple):
        (rv, status_or_headers, headers) = rv + (None,) * (3 - len(rv))
    if rv is None:
        raise ValueError('View function did not return a response')
    if isinstance(status_or_headers, (dict, list)):
        (headers, status_or_headers) = (status_or_headers, None)
    if not isinstance(rv, self.response_class):
        if isinstance(rv, (text_type, bytes, bytearray)):
            rv = self.response_class(rv, headers=headers, status=status_or_headers)
            headers = status_or_headers = None
        else:
            rv = self.response_class.force_type(rv, request.environ)
    if status_or_headers is not None:
        if isinstance(status_or_headers, string_types):
            rv.status = status_or_headers
        else:
            rv.status_code = status_or_headers
    if headers:
        rv.headers.extend(headers)
    return rv","def make_response(self, rv):
    """"""Convert the return value from a view function to an instance of
        :attr:`response_class`.

        :param rv: the return value from the view function. The view function
            must return a response. Returning ``None``, or the view ending
            without returning, is not allowed. The following types are allowed
            for ``view_rv``:

            ``str`` (``unicode`` in Python 2)
                A response object is created with the string encoded to UTF-8
                as the body.
                
            ``bytes`` (``str`` in Python 2)
                A response object is created with the bytes as the body.
                
            ``tuple``
                Either ``(body, status, headers)``, ``(body, status)``, or
                ``(body, headers)``, where ``body`` is any of the other types
                allowed here, ``status`` is a string or an integer, and
                ``headers`` is a dictionary or a list of ``(key, value)``
                tuples. If ``body`` is a :attr:`response_class` instance,
                ``status`` overwrites the exiting value and ``headers`` are
                extended.
    
            :attr:`response_class`
                The object is returned unchanged.
            
            other :class:`~werkzeug.wrappers.Response` class
                The object is coerced to :attr:`response_class`.
                
            :func:`callable`
                The function is called as a WSGI application. The result is
                used to create a response object.

        .. versionchanged:: 0.9
           Previously a tuple was interpreted as the arguments for the
           response object.
        """"""
    status = headers = None
    if isinstance(rv, (tuple, list)):
        len_rv = len(rv)
        if len_rv == 3:
            (rv, status, headers) = rv
        elif len_rv == 2:
            if isinstance(rv[1], (Headers, dict, tuple, list)):
                (rv, headers) = rv
            else:
                (rv, status) = rv
        else:
            raise TypeError('The view function did not return a valid response tuple. The tuple must have the form (body, status, headers), (body, status), or (body, headers).')
    if rv is None:
        raise TypeError('The view function did not return a valid response. The function either returned None or ended without a return statement.')
    if not isinstance(rv, self.response_class):
        if isinstance(rv, (text_type, bytes, bytearray)):
            rv = self.response_class(rv, status=status, headers=headers)
            status = headers = None
        else:
            try:
                rv = self.response_class.force_type(rv, request.environ)
            except TypeError as e:
                new_error = TypeError('{e}\nThe view function did not return a valid response. The return type must be a string, tuple, Response instance, or WSGI callable, but it was a {rv.__class__.__name__}.'.format(e=e, rv=rv))
                reraise(TypeError, new_error, sys.exc_info()[2])
    if status is not None:
        if isinstance(status, (text_type, bytes, bytearray)):
            rv.status = status
        else:
            rv.status_code = status
    if headers:
        rv.headers.extend(headers)
    return rv",False,[]
819,5e8dd8b2872584483e7fb7506337a7d940ea8cc0,helpers.py,test_json_key_sorting,False,"def test_json_key_sorting(self):
    app = flask.Flask(__name__)
    app.testing = True
    self.assert_equal(app.config['JSON_SORT_KEYS'], True)
    d = dict.fromkeys(range(20), 'foo')

    @app.route('/')
    def index():
        return flask.jsonify(values=d)
    c = app.test_client()
    rv = c.get('/')
    lines = [x.strip() for x in rv.data.strip().decode('utf-8').splitlines()]
    self.assert_equal(lines, ['{', '""values"": {', '""0"": ""foo"",', '""1"": ""foo"",', '""2"": ""foo"",', '""3"": ""foo"",', '""4"": ""foo"",', '""5"": ""foo"",', '""6"": ""foo"",', '""7"": ""foo"",', '""8"": ""foo"",', '""9"": ""foo"",', '""10"": ""foo"",', '""11"": ""foo"",', '""12"": ""foo"",', '""13"": ""foo"",', '""14"": ""foo"",', '""15"": ""foo"",', '""16"": ""foo"",', '""17"": ""foo"",', '""18"": ""foo"",', '""19"": ""foo""', '}', '}'])","def test_json_key_sorting(self):
    app = flask.Flask(__name__)
    app.testing = True
    self.assert_equal(app.config['JSON_SORT_KEYS'], True)
    d = dict.fromkeys(range(20), 'foo')

    @app.route('/')
    def index():
        return flask.jsonify(values=d)
    c = app.test_client()
    rv = c.get('/')
    lines = [x.strip() for x in rv.data.strip().decode('utf-8').splitlines()]
    sorted_by_str = ['{', '""values"": {', '""0"": ""foo"",', '""1"": ""foo"",', '""10"": ""foo"",', '""11"": ""foo"",', '""12"": ""foo"",', '""13"": ""foo"",', '""14"": ""foo"",', '""15"": ""foo"",', '""16"": ""foo"",', '""17"": ""foo"",', '""18"": ""foo"",', '""19"": ""foo"",', '""2"": ""foo"",', '""3"": ""foo"",', '""4"": ""foo"",', '""5"": ""foo"",', '""6"": ""foo"",', '""7"": ""foo"",', '""8"": ""foo"",', '""9"": ""foo""', '}', '}']
    sorted_by_int = ['{', '""values"": {', '""0"": ""foo"",', '""1"": ""foo"",', '""2"": ""foo"",', '""3"": ""foo"",', '""4"": ""foo"",', '""5"": ""foo"",', '""6"": ""foo"",', '""7"": ""foo"",', '""8"": ""foo"",', '""9"": ""foo"",', '""10"": ""foo"",', '""11"": ""foo"",', '""12"": ""foo"",', '""13"": ""foo"",', '""14"": ""foo"",', '""15"": ""foo"",', '""16"": ""foo"",', '""17"": ""foo"",', '""18"": ""foo"",', '""19"": ""foo""', '}', '}']
    try:
        self.assert_equal(lines, sorted_by_int)
    except AssertionError:
        self.assert_equal(lines, sorted_by_str)",False,[]
